const fs = require("fs");
const Interaction = require("../modals/Interaction"); // Pastikan path-nya benar
const Product = require('../modals/ProductSchema'); // pastikan path sesuai
const User = require('../modals/UserSchema'); // pastikan path sesuai

// üîπ Tambah interaksi user
exports.addInteraction = async (req, res) => {
  try {
    const { user_id, product_id, interaction_type, interaction_value } = req.body;

    const interaction = new Interaction({
      user_id,
      product_id,
      interaction_type,
      interaction_value,
    });

    await interaction.save();

    res.status(201).json({ message: "Interaksi disimpan", data: interaction });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// üîπ Ambil semua interaksi
exports.getAllInteractions = async (req, res) => {
  try {
    const data = await Interaction.find();
    res.json(data);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};

// üîπ Rekomendasi berbasis Collaborative Filtering
const computeCosineSimilarity = (vecA, vecB) => {
  const allItems = new Set([...Object.keys(vecA), ...Object.keys(vecB)]);
  let dotProduct = 0, magnitudeA = 0, magnitudeB = 0;

  allItems.forEach(item => {
    const a = vecA[item] || 0;
    const b = vecB[item] || 0;
    dotProduct += a * b;
    magnitudeA += a * a;
    magnitudeB += b * b;
  });

  if (magnitudeA === 0 || magnitudeB === 0) return 0;
  return dotProduct / (Math.sqrt(magnitudeA) * Math.sqrt(magnitudeB));
};

exports.getRecommendationForUser = async (req, res) => {
  try {
    const userId = req.params.userId;

    const [interactions, allProducts, allUsers] = await Promise.all([
      Interaction.find(),
      Product.find(),
      User.find()
    ]);

    // Map produk
    const productMap = {};
    allProducts.forEach((product, index) => {
      productMap[product._id.toString()] = product.NAMA || `Product ${index + 1}`;
    });

    // Map user
    const userMap = {};
    allUsers.forEach(user => {
      userMap[user._id.toString()] = {
        name: user.name || "Unknown",
        email: user.email || "",
        ...user.toObject()
      };
    });

    // Matriks interaksi user -> produk
    const matrix = {};
    interactions.forEach(({ user_id, product_id, interaction_value }) => {
      if (!matrix[user_id]) matrix[user_id] = {};
      matrix[user_id][product_id] = (matrix[user_id][product_id] || 0) + interaction_value;
    });

    const targetUserVector = matrix[userId] || {};

    // Hitung similarity antar user
    const similarityScores = [];
    Object.entries(matrix).forEach(([otherUserId, vector]) => {
      if (otherUserId === userId) return;
      const similarity = computeCosineSimilarity(targetUserVector, vector);
      if (similarity > 0) {
        similarityScores.push({
          userId: otherUserId,
          similarity,
          interactions: vector
        });
      }
    });

    const clickCountMap = {};
    interactions.forEach(({ product_id }) => {
      const id = product_id.toString();
      clickCountMap[id] = (clickCountMap[id] || 0) + 1;
    });

    // Hitung skor rekomendasi
    const scores = [];

    allProducts.forEach(product => {
      const productId = product._id.toString();
      const clickCount = clickCountMap[productId] || 0;
      if (targetUserVector[productId]) return; // skip yang sudah diinteraksikan

      let scoreNumerator = 0;
      let scoreDenominator = 0;

      for (let user of similarityScores) {
        const interactionValue = user.interactions[productId] || 0;
        scoreNumerator += user.similarity * interactionValue;
        scoreDenominator += Math.abs(user.similarity);
      }

      const score = scoreDenominator === 0 ? 0 : scoreNumerator / scoreDenominator;

      console.log("=================================================");
      console.log("productId :", productId);
      console.log("scoreNumerator :", scoreNumerator);
      console.log("scoreDenominator :", scoreDenominator);
      console.log("score :", score);

      scores.push({
        ...product.toObject(),
        score,
        total_clicks: clickCount,
      });
    });

    const sortedRecommendations = scores.sort((a, b) => b.score - a.score);

    // Format interaksi user
    const interactionData = Object.entries(matrix).map(([uid, products]) => ({
      user_id: uid,
      name: userMap[uid]?.name || "Unknown",
      interactions: Object.entries(products).map(([pid, value]) => ({
        product_id: pid,
        product_name: productMap[pid] || pid,
        interaction_value: value
      }))
    }));

    res.json({
      success: true,
      userId,
      recommendations: sortedRecommendations,
      interactions: interactionData
    });

  } catch (error) {
    console.error(error);
    res.status(500).json({
      success: false,
      message: 'Gagal memproses rekomendasi',
      error: error.message,
    });
  }
};


// üîπ Import JSON file interaksi
exports.importInteractions = async (req, res) => {
  try {
    const rawData = fs.readFileSync(req.file.path, "utf8");

    let data;
    try {
      data = JSON.parse(rawData);
    } catch (parseError) {
      return res.status(400).json({ success: false, message: "File JSON tidak valid" });
    }

    const interactions = data.map(doc => {
      // console.log(doc.timestamp.$date)
      let parsedTimestamp = new Date(doc.timestamp.$date);
      if (isNaN(parsedTimestamp)) {
        console.warn("‚ö†Ô∏è Invalid timestamp found, using current date:", doc);
        parsedTimestamp = new Date(); // fallback ke waktu saat ini
      }

      return {
        user_id: doc.user_id,
        product_id: doc.product_id,
        interaction_type: doc.interaction_type,
        interaction_value: doc.interaction_value,
        timestamp: parsedTimestamp
      };
    });
    // console.log(interactions)

    const BATCH_SIZE = 100;
    let totalInserted = 0;

    for (let i = 0; i < interactions.length; i += BATCH_SIZE) {
      const chunk = interactions.slice(i, i + BATCH_SIZE);

      try {
        // console.log("1. ", chunk)clear
        await Interaction.insertMany(chunk, { ordered: false });
        totalInserted += chunk.length;
      } catch (err) {
        console.error(`‚ùå Error saat insert batch ${i / BATCH_SIZE + 1}:`, err.message);
      }
    }

    fs.unlinkSync(req.file.path); // hapus file setelah selesai

    res.json({
      success: true,
      message: `Import selesai`,
      totalInserted,
      totalProcessed: interactions.length
    });

  } catch (err) {
    console.error("‚ùå Error global:", err);
    res.status(500).json({ success: false, message: "Gagal mengimpor interaksi", error: err.message });
  }
};
